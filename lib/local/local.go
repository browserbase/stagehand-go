// Custom code. Not generated by Stainless.
package local

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"syscall"
	"time"
)

const (
	stagehandRepo    = "browserbase/stagehand"
	defaultUserAgent = "stagehand-go/local"
	apiTimeout       = 15 * time.Second
	downloadTimeout  = 10 * time.Minute
)

var downloadMu sync.Mutex

// platformTag returns the platform and architecture tags for the current system.
// Platform is one of: darwin, linux, win32
// Arch is one of: arm64, x64
func platformTag() (platform, arch string) {
	switch runtime.GOOS {
	case "darwin":
		platform = "darwin"
	case "linux":
		platform = "linux"
	case "windows":
		platform = "win32"
	default:
		platform = runtime.GOOS
	}

	switch runtime.GOARCH {
	case "amd64":
		arch = "x64"
	case "arm64":
		arch = "arm64"
	default:
		arch = runtime.GOARCH
	}

	return platform, arch
}

// binaryFilename returns the expected binary filename for the current platform.
// Format: stagehand-server-{platform}-{arch}[.exe]
func binaryFilename() string {
	platform, arch := platformTag()
	name := fmt.Sprintf("stagehand-server-%s-%s", platform, arch)
	if runtime.GOOS == "windows" {
		name += ".exe"
	}
	return name
}

// cacheDir returns the default cache directory for local binaries.
// Uses XDG_CACHE_HOME on Linux, ~/Library/Caches on macOS, and %LOCALAPPDATA% on Windows.
func cacheDir() string {
	var cacheBase string

	switch runtime.GOOS {
	case "darwin":
		home, err := os.UserHomeDir()
		if err != nil {
			cacheBase = "/tmp"
		} else {
			cacheBase = filepath.Join(home, "Library", "Caches")
		}
	case "windows":
		cacheBase = os.Getenv("LOCALAPPDATA")
		if cacheBase == "" {
			home, err := os.UserHomeDir()
			if err != nil {
				cacheBase = os.TempDir()
			} else {
				cacheBase = filepath.Join(home, "AppData", "Local")
			}
		}
	default: // linux and others
		cacheBase = os.Getenv("XDG_CACHE_HOME")
		if cacheBase == "" {
			home, err := os.UserHomeDir()
			if err != nil {
				cacheBase = "/tmp"
			} else {
				cacheBase = filepath.Join(home, ".cache")
			}
		}
	}

	return filepath.Join(cacheBase, "stagehand", "local")
}

// ResolveBinaryPath ensures the local mode binary exists and returns its path.
func ResolveBinaryPath() (string, error) {
	filename := binaryFilename()

	// Check cache directory first.
	cachePath := filepath.Join(cacheDir(), filename)
	if _, err := os.Stat(cachePath); err == nil {
		return cachePath, nil
	}

	downloadMu.Lock()
	defer downloadMu.Unlock()

	if _, err := os.Stat(cachePath); err == nil {
		return cachePath, nil
	}

	version := os.Getenv("STAGEHAND_SERVER_VERSION")
	if version == "" {
		version = "latest"
	}

	ctx, cancel := context.WithTimeout(context.Background(), downloadTimeout)
	defer cancel()

	tag, err := resolveVersion(ctx, version)
	if err != nil {
		return "", fmt.Errorf("failed to resolve stagehand driver binary version: %w (possibly blocked by firewall or sandbox settings). %s", err, manualDownloadHint(filename, cachePath))
	}

	if err := downloadBinary(ctx, tag, cachePath); err != nil {
		return "", fmt.Errorf("failed to download latest stagehand driver binary to: %w (possibly blocked by firewall or sandbox settings). %s", err, manualDownloadHint(filename, cachePath))
	}

	return cachePath, nil
}

type releaseInfo struct {
	TagName string `json:"tag_name"`
}

func manualDownloadHint(filename, destPath string) string {
	return fmt.Sprintf(
		"To continue, download the %s driver binary from the latest release on https://github.com/%s/releases and save it to: %s",
		filename,
		stagehandRepo,
		destPath,
	)
}

func resolveVersion(ctx context.Context, version string) (string, error) {
	if version == "" || version == "latest" {
		return fetchLatestTag(ctx)
	}
	if !strings.HasPrefix(version, "stagehand-server/") {
		version = "stagehand-server/" + version
	}
	return version, nil
}

func fetchLatestTag(ctx context.Context) (string, error) {
	url := fmt.Sprintf("https://api.github.com/repos/%s/releases?per_page=15", stagehandRepo)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}
	req.Header.Set("User-Agent", defaultUserAgent)

	client := &http.Client{Timeout: apiTimeout}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return "", fmt.Errorf("failed to fetch releases: %s", resp.Status)
	}

	var releases []releaseInfo
	if err := json.NewDecoder(resp.Body).Decode(&releases); err != nil {
		return "", err
	}
	for _, release := range releases {
		if strings.HasPrefix(release.TagName, "stagehand-server/") {
			return release.TagName, nil
		}
	}

	return "", fmt.Errorf("failed to find stagehand-server release tag")
}

func downloadBinary(ctx context.Context, version, destPath string) error {
	filename := binaryFilename()
	url := fmt.Sprintf("https://github.com/%s/releases/download/%s/%s", stagehandRepo, version, filename)

	if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil {
		return fmt.Errorf("failed to create cache directory: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	req.Header.Set("User-Agent", defaultUserAgent)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("failed to download binary: %s", resp.Status)
	}

	tmpPath := destPath + ".tmp"
	file, err := os.OpenFile(tmpPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}

	if _, err := io.Copy(file, resp.Body); err != nil {
		file.Close()
		_ = os.Remove(tmpPath)
		return err
	}

	if err := file.Close(); err != nil {
		_ = os.Remove(tmpPath)
		return err
	}

	if err := os.Rename(tmpPath, destPath); err != nil {
		_ = os.Remove(tmpPath)
		return err
	}

	return nil
}

// ServerManager manages the lifecycle of local mode.
type ServerManager struct {
	binaryPath           string
	cmd                  *exec.Cmd
	baseURL              string
	modelAPIKey          string
	browserbaseAPIKey    string
	browserbaseProjectID string
	mu                   sync.Mutex
	started              bool
}

const (
	defaultHost         = "127.0.0.1"
	defaultReadyTimeout = 30 * time.Second
)

// NewServerManager creates a new ServerManager.
// It resolves the binary path immediately and returns an error if not found.
func NewServerManager() (*ServerManager, error) {
	binaryPath, err := ResolveBinaryPath()
	if err != nil {
		return nil, err
	}

	return &ServerManager{
		binaryPath: binaryPath,
	}, nil
}

// EnsureRunning starts local mode if not already running and waits for it to be ready.
// Returns the base URL of the running process.
func (m *ServerManager) EnsureRunning(ctx context.Context) (string, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if m.started && m.cmd != nil && m.cmd.Process != nil {
		// Check if process is still running
		if m.isProcessRunning() {
			return m.baseURL, nil
		}
		// Process died, reset state
		m.started = false
		m.cmd = nil
	}

	return m.startLocked(ctx)
}

// SetModelAPIKey sets the model API key used when starting local mode.
func (m *ServerManager) SetModelAPIKey(key string) {
	if key == "" {
		return
	}
	m.mu.Lock()
	defer m.mu.Unlock()
	m.modelAPIKey = key
}

// SetBrowserbaseAPIKey sets the Browserbase API key used by local mode.
func (m *ServerManager) SetBrowserbaseAPIKey(key string) {
	if key == "" {
		return
	}
	m.mu.Lock()
	defer m.mu.Unlock()
	m.browserbaseAPIKey = key
}

// SetBrowserbaseProjectID sets the Browserbase project ID used by local mode.
func (m *ServerManager) SetBrowserbaseProjectID(projectID string) {
	if projectID == "" {
		return
	}
	m.mu.Lock()
	defer m.mu.Unlock()
	m.browserbaseProjectID = projectID
}

// startLocked starts local mode. Must be called with m.mu held.
func (m *ServerManager) startLocked(ctx context.Context) (string, error) {
	// Pick a free port if not specified
	port, err := findFreePort()
	if err != nil {
		return "", fmt.Errorf("failed to find free port: %w", err)
	}

	// Build environment
	env := os.Environ()
	env = append(env,
		"NODE_ENV=production",
		"BB_ENV=local",
		fmt.Sprintf("HOST=%s", defaultHost),
		fmt.Sprintf("PORT=%d", port),
	)

	if m.modelAPIKey != "" {
		env = append(env, fmt.Sprintf("MODEL_API_KEY=%s", m.modelAPIKey))
	}
	if m.browserbaseAPIKey != "" {
		env = append(env, fmt.Sprintf("BROWSERBASE_API_KEY=%s", m.browserbaseAPIKey))
	}
	if m.browserbaseProjectID != "" {
		env = append(env, fmt.Sprintf("BROWSERBASE_PROJECT_ID=%s", m.browserbaseProjectID))
	}

	// Start the process
	m.cmd = exec.Command(m.binaryPath)
	m.cmd.Env = env
	m.cmd.Stdout = os.Stdout
	m.cmd.Stderr = os.Stderr

	if err := m.cmd.Start(); err != nil {
		return "", fmt.Errorf("failed to start local mode: %w", err)
	}

	m.baseURL = fmt.Sprintf("http://%s:%d", defaultHost, port)
	m.started = true

	// Wait for local mode to be ready.
	if err := m.waitForReady(ctx); err != nil {
		// Kill the process if we fail to connect
		_ = m.Close()
		return "", err
	}

	return m.baseURL, nil
}

// waitForReady polls health endpoints until local mode is ready or timeout.
func (m *ServerManager) waitForReady(ctx context.Context) error {
	healthEndpoints := []string{"/readyz", "/healthz", "/health"}

	deadline := time.Now().Add(defaultReadyTimeout)
	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	client := &http.Client{
		Timeout: 2 * time.Second,
	}

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			if time.Now().After(deadline) {
				return fmt.Errorf("local mode failed to become ready within %v", defaultReadyTimeout)
			}

			// Check if process died
			if !m.isProcessRunning() {
				return fmt.Errorf("local mode process exited unexpectedly")
			}

			// Try each health endpoint
			for _, endpoint := range healthEndpoints {
				url := m.baseURL + endpoint
				resp, err := client.Get(url)
				if err != nil {
					continue
				}
				resp.Body.Close()

				if resp.StatusCode >= 200 && resp.StatusCode < 300 {
					return nil
				}
			}
		}
	}
}

// isProcessRunning checks if the process is still running.
func (m *ServerManager) isProcessRunning() bool {
	return processRunning(m.cmd)
}

// Close stops local mode gracefully.
// It sends SIGTERM first, waits up to 3 seconds, then sends SIGKILL if needed.
func (m *ServerManager) Close() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	if !m.started || m.cmd == nil || m.cmd.Process == nil {
		return nil
	}

	// Send SIGTERM
	if err := m.cmd.Process.Signal(syscall.SIGTERM); err != nil {
		// Process might already be dead
		if !m.isProcessRunning() {
			m.started = false
			return nil
		}
	}

	// Wait for graceful shutdown with timeout
	done := make(chan error, 1)
	go func() {
		done <- m.cmd.Wait()
	}()

	select {
	case <-done:
		// Process exited
		m.started = false
		return nil
	case <-time.After(3 * time.Second):
		// Timeout, force kill
		if err := m.cmd.Process.Kill(); err != nil {
			return fmt.Errorf("failed to kill process: %w", err)
		}
		<-done // Wait for Wait() to complete
		m.started = false
		return nil
	}
}

// findFreePort finds an available TCP port on localhost.
func findFreePort() (int, error) {
	listener, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		return 0, err
	}
	defer listener.Close()

	addr := listener.Addr().(*net.TCPAddr)
	return addr.Port, nil
}
